package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil // присваиваем ЗНАЧЕНИЕ nil
	return err                  // возвращаем error интерфейс, в котором тип будет *os.PathError, а значением nil
}

func main() {
	// Вызываем функцию, и получаем интерфейс -> (тип *os.PathError, значение nil)
	err := Foo()
	fmt.Println(err)        // выведет <nil>, потому что печатается значение интерфейса
	fmt.Println(err == nil) // вывод будет false, так как интерфейс типа err имеет *os.PathError, поэтому *os.PathError и nil не равны
}

// Отвечая на вопрос: "Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов."
// Можно сказать следующее:
// Интерфейс имеет структуру из двух составных частей, а именно ТИП и ЗНАЧЕНИЕ.
// Что не скажешь про пустой интерфейс, он совместим с любым типом, и не требует никаких конкретных типов, то есть можем передать что угодно
